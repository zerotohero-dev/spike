```txt
  \\ 
 \\\\ SPIKE: Keep your secrets secret with SPIFFE.
\\\\\\
```

## SPIKE Design Document

SPIKE (Secure Production Identity for Key Encryption) is a secrets management
system build on top of a SPIFFE identity control plane, consisting of three
components:

* **SPIKE Nexus** (./nexus)
* **SPIKE Pilot** (./spike)
* And **SPIKE Keeper** (./keeper)

The system provides high availability for secret storage with a manual recovery
mechanism in case of irrecoverable failure.

## Components

### SPIKE Nexus

* **SPIKE Nexus** is the primary component responsible for secrets management.
* It creates and manages the root encryption key.
* It handles secret encryption and decryption.
* It snycs to root encryption key with **SPIKE Keeper** regularly.
* It provides an admin interface for key management.

### SPIKE Keeper

* It is designed to be simple and reliable.
* Its only goal is to keep a copy of the root key in memory.
* It enables automatic recovery if **SPIKE Nexus** crashes.
* It is co-located with **SPIKE Nexus** (on the same machine/node).

### SPIKE Pilot

* It is the CLI to the system.
* It converts CLI commands to RESTful mTLS API calls to **SPIKE Nexus**.
* It is the only management entry point to the system.
* Deleting/disabling/removing **SPIKE Pilot** reduces the attack surface
  of the system since admin operation will not be possible without
  **SPIKE Pilot**.

### SPIKE Mint

**SPIKE Mint** is a standalone utility for generating initialization tokens.
It creates cryptographically secure tokens with metadata:

**Features**:
* 256 bits of entropy per token
* Version tracking
* Creation timestamp
* Purpose field
* Optional expiry
* HMAC-based integrity verification
* Base64 encoded for transport
* CLI interface for admin usage
* Can validate existing tokens
* Ensures standardization of token format and security

## Security Model

### Authentication and Communication

* All inter-component communication is secured through SPIFFE mTLS.
* Components identify each other using their SVIDs.
* Network-level security is provided by SPIFFE mTLS.

### Trust Boundaries

* Primary trust boundary is at the machine level.
* If **SPIKE Keeper** is compromised, the machine is considered compromised.
* Both **SPIKE Nexus** and **SPIKE Keeper** are hardened. They use distroless
  containers to prevent various attack vectors.
* The design assumes (*but does not mandate*) a containerized environment
  (*such as Docker or Kubernetes*). If containerization is not possible, 
  components can still work identically, assuming they can establish
  SPIFFE mTLS securely.
* Physical, and OS-level security are important.

## Key Management

* The system assumes a long-lived, well-guarded, initial root key.
* The root key is automatically generated by **SPIKE Nexus** and it's
  **never** store on disk in plain text (*i.e., it alwyas lives in 
  memory*)
* An administrator (*through SPIKE Pilot*) can provide a public key for
  encrypted root key backup.
* Key rotation will also re-encrypt secrets.

## Administrative Access

* Initial provisioning requires an admin initialization token.
* The token is generated using **SPIKE Mint**
* Token used for first-time setup and root key creation
* While machine access could technically bypass controls, token provides:
  * Audit trail of initialization
  * Protection against accidental re-initialization
  * Privilege separation between system and security administrators
  * Integration point for automation and IaC

## Multi-Admin Support

* Initial admin uses **SPIKE Mint** to create the first initialization token.
* Additional admins can be authorized through token management API.
* Each admin can have their own valid token.

Token operations:
* Add new admin token (requires existing admin authorization)
* Remove admin token
* List admin tokens (metadata only)
* Validate token status

Benefits:
* Support for multiple administrators
* Emergency access procedures
* Token revocation capabilities
* Clear audit trail of admin access

## Recovery

### SPIKE Nexus Crash Recovery

1. **SPIKE Nexus** crashes.
2. New **SPIKE Nexus** instance starts.
3. **SPIKE Nexus** authenticates to SPIKE Keeper using SPIFFE mTLS.
4. **SPIKE Keeper** provides the root key over mTLS.
5. **SPIKE Nexus** resumes normal operation.

### Complete System Recovery

1. Both **SPIKE Nexus**, **SPIKE Keeper** are unavaiable, or the system is
  in on other irrecoverable state.
2. Admin retrieves encrpted root key.
3. Admin decrypts the root key using their private key.
4. Admin reinitializes **SPIKE Nexus** using the decrypted root key.
5. The system resumes normal operation.

## Data Consistency

* If the root key changes during recovery, the old encrypted data becomes
  invalid.
* Securely backing up the root key is critical for data consistency and
  recovery.

## Monitoring and Observability

### Health Metrics

* Basic health, liveness, readiness probes for all components.
* Prometheus integration for metrics collection.

### Key Metrics

* Number of secrets stored.
* Memory utilization.
* Failed authentication attempts.
* Time since last Nexus-Keeper snyc.
* Root key age

## Future Considerations

### Potential Enhancements

* Automated key rotation
* Multiple Keeper instances for redundancy
* Various backing stores (file system, postgres, cloud secrets store)
* Key versioning for tracking encryption history

### Additional Monitoring

* Advanced authentication metrics
* Key usage statistics
* Performance metrics for crypto operations.

## Security Recommendations

* Use filesystem encryption
* Regular security audits for machines and key components
* Strict access control
* Regular backup verification of encrpted root key
* Monitoring for anomalies and unusual access patterns

## Architecture Decision Records

The [`./adrs`](adrs) folder contains Architecture Decision Records for the
project.

## Sequence Diagrams 

### SPIKE Nexus Root Key Provisioning and Recovery

```mermaid
sequenceDiagram
    participant N as SPIKE Nexus
    participant K as SPIKE Keeper
    alt not initialized
        Note over N: Create root key.

        N->>+K: Send root key 
    else already initialized
        alt root key is empty
            N->>+K: Fetch root key 
            K->>+N: {root key}
            Note over N,K: Log if root key is still empty.
            Note over N,K: If root key is empty,<br>Manual admin intervention is required.
        end
    end

    loop Every 5mins
        alt SPIKE nexus not initialized
            Note over N,K: skip this iteration.
        end

        alt when root key empty
            N->>+K: Fetch root key 
            K->>+N: {root key}

            Note right of N: Log, if root key is still empty.
            Note right of N: Skip the rest of the loop.
        else is root key in memory
            N->>+K: Send root key

            Note over K: Cache in Memory
        end
    end
```

### SPIKE Initialization

```mermaid
sequenceDiagram
    participant P as SPIKE Pilot (spike)
    participant N as SPIKE Nexus
    participant K as SPIKE Keeper

    P->>+N: any API request

    Note over N: Check the database for initialization status.
    Note over N: Maybe create initial db schema if not exists.

    N->>+P: not initialized. initialize the system first.

    Note over P: user enters `spike init` from cli.

    Note over P:  prompt for a password.

    P->>+N: init { password }

    alt not initialized
        Note over N: create a root key
        Note over N: keep root key in memory
        Note over N: encrypt root key with the password

        N->>+K: cache the root key for redundancy

        alt try exponential
            Note over N: Save the encrypted root key in the database.
            Note over N: Verify database record.
        else failure after exhausting retries
            Note over N,K: return
            Note over N,K: system failed to initialize
        end
       
        alt try exponential 
            Note over N: Create an `initialized` tombstone in the database.
        end

        Note over P: `spike login` will exchange the password with a short-lived session token.
    else already initialized
        N->>+P: error: already initialized
    end
```

### SPIKE Login

```mermaid
sequenceDiagram
    participant P as SPIKE Pilot (spike)
    participant N as SPIKE Nexus
    
    Note over P: This is for the admin user.<br>Any user that admin user creates will need<br>to provide a username too.
    Note over P: SPIKE Pilot will ask for password<br>before sending the login request.
    Note over P: Verify root token existence before login.
    Note over P: If root token cannot be recovered, warn admin that they may need to rekey/recover.
    Note over P: If not initialized, warn user to initialize first.

    P->>+N: spike login 
    N->>+P: send temporary session token.

    Note over P: Save session token to the file system.
    Note over P: Use session token for any request to SPIKE Nexus.
    Note over P: TTL of token and the place the token<br>is saved are customizable.
```

### SPIKE Nexus Automatic Recovery After Crash

```mermaid
sequenceDiagram
    Note over N,K: Whenever possible, retry<br>with exponential backoff

    participant N as SPIKE Nexus
    participant K as SPIKE Keeper
    alt not initialized
        Note over N: Generate root key with strong entropy
        Note over N: Validate key format and strength

        N->>+K: Send root key 
        K-->>N: Acknowledge receipt

        Note over K: Verify key format before caching        
    else already initialized
        alt root key is empty
            N->>+K: Request root key 
            K-->>N: {root key}
            Note over N,K: Log if root key is still empty.
            Note over N,K: If root key is empty,<br>Manual admin intervention is required.
        end
    end

    loop Every 5mins (configurable)
        alt SPIKE Nexus not initialized
            Note over N,K: skip this iteration.
        end

        alt SPIKE Keep unreachable
            Note over N,K: skip this iteration.
        end

        alt when root key empty
            N->>+K: Fetch root key 
            K-->>N: {root key}

            Note right of N: Log, if root key is still empty.
            Note right of N: Skip the rest of the loop.
        else is root key in memory
            N->>+K: Send root key

            Note over K: Cache in Memory
        end
    end
```

### SPIKE Manual System Re-Initialization

```mermaid 
sequenceDiagram
    participant P as SPIKE Pilot (spike)
    participant N as SPIKE Nexus

    Note over P,N: Total system crash.<br>SPIKE Pilot is<br>unable to recover the root key.

    Note over P: Admin logs in (with password)
    Note over P: Admin execute `spike recover`
    Note over P: Confirm: Are you sure?
    Note over P: Request admin password (i.e. don't trust the session key)

    P->>+N: POST /v1/recover

    Note over N: Use password to decrypt the root key in the db.
    
    Note over N: Validate the decrypted root key.

    Note over N: Root key is restored, normal operation can continue.
```

### SPIKE Forced Root Key Reset

This will make all the stored secrets obsolete, so it should be done
as a last resort. This may be required in cases where the database has been
corrupted, or the admin user has lost access to their password manager
(we hope that they don't memorize passwords, and they have more trusted ways
of keeping random long-lived passwords elsewhere, like system keyring, or a 
password manager).

```mermaid
sequenceDiagram
    participant P as Admin User
        Note over P: This is an out-of-band operation.<br>It will not touch SPIRE #semi;<br>however it will reset SPIKE to its day zero setting.
    alt skies have fallen apart
        Note over P: Total system crash.<br>Admin forgot their password.<br>Database corrupt.<br>Or the system is in a similar irrecoverable state.
        Note over P: Admin runs `./hack/reset.sh` to reset the system to day zero.
        Note over P: Prompt: Are you really sure? This will wipe all secrets. And it's irreversible.
        Note over P: Any key or token saved on the file system will be wiped out.
        Note over P: The database will be reset to the initial state.
        Note over P: SPIKE Pilot and SPIKE Nexus will be restarted.
        Note over P: System reset. Admin can re-run `spike init`.
        Note over P: Explicitly verify the system state after reset.
        Note over P: Confirm all component restarts.
        Note over P: Validate database reset.
    end
```

## SPIKE Database Usage

**SPIKE Nexus** is the only client for the backing store (*Postgres DB*).

Here are the things **SPIKE Nexus stores in the db.

* **root key** (*encrypted with the admin password*)
* **admin token** (*encrypted with the root key*)
* **session keys** (*encrypted with the root key*)
* **secrets** (*encrypted with the root key*)

Note that both **admin token**, **session keys**, and **secrets**, are a kinds 
of secrets from the data storage perspective.

Also note that **SPIKE Pilot** (i.e. `spike`) can save temporary session keys
and encrypted admin tokens on disk for convenience. Whereas **SPIKE Nexus** 
will either store things in memory or keep them encrypted in a database, **never**
saving anything on the file system.

## SPIKE Data Model

Here is an initial data model (*subject to change during implementation*)

Note that for simplicity, we'll initially only support **Postgres** as a
backing store.

```sql
-- Enable UUID generation
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Enum for different types of secrets
CREATE TYPE secret_type AS ENUM ('admin_token', 'session_key', 'secret');

-- Store the root key (encrypted with admin password)
CREATE TABLE root_keys (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    encrypted_key bytea NOT NULL,
    key_hash bytea NOT NULL,  -- For verification
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    last_rotated_at timestamp with time zone,
    active boolean DEFAULT true,
    CONSTRAINT single_active_key UNIQUE (active)
);

-- Store all types of secrets (encrypted with root key)
CREATE TABLE secrets (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    name varchar(255) NOT NULL,
    type secret_type NOT NULL,
    encrypted_data bytea NOT NULL,
    metadata jsonb,  -- For additional secret-specific data
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    expires_at timestamp with time zone,
    version integer DEFAULT 1,
    previous_version_id uuid REFERENCES secrets(id),
    CONSTRAINT unique_active_name UNIQUE (name, type)
);

-- Audit log for all operations
CREATE TABLE audit_logs (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    operation varchar(50) NOT NULL,
    secret_id uuid REFERENCES secrets(id),
    metadata jsonb,
    performed_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for better performance
CREATE INDEX idx_secrets_type ON secrets(type);
CREATE INDEX idx_secrets_name ON secrets(name);
CREATE INDEX idx_audit_logs_secret_id ON audit_logs(secret_id);
CREATE INDEX idx_audit_logs_performed_at ON audit_logs(performed_at);

-- Add triggers for updating 'updated_at' timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_secrets_updated_at
    BEFORE UPDATE ON secrets
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```
